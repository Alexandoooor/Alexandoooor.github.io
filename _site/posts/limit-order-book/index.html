<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Implenting a Limit Order Book in golang | Alexander’s Portfolio</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Implenting a Limit Order Book in golang" />
<meta name="author" content="Alexander" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="What is a Limit Order Book?" />
<meta property="og:description" content="What is a Limit Order Book?" />
<link rel="canonical" href="http://localhost:4000/posts/limit-order-book/" />
<meta property="og:url" content="http://localhost:4000/posts/limit-order-book/" />
<meta property="og:site_name" content="Alexander’s Portfolio" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-10-24T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Implenting a Limit Order Book in golang" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Alexander"},"dateModified":"2025-10-24T00:00:00+02:00","datePublished":"2025-10-24T00:00:00+02:00","description":"What is a Limit Order Book?","headline":"Implenting a Limit Order Book in golang","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/posts/limit-order-book/"},"url":"http://localhost:4000/posts/limit-order-book/"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=684c9a686574d9e286b2b0816e35b9450fd9e169">
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://localhost:4000/">Alexander's Portfolio</a></h1>

        

        <p>A collection of my projects and thoughts!</p>

        <ul>
            <li><a href="/posts/">Posts</a></li>
            <li><a href="/about/">About me</a></li>
            <li><a href="https://github.com/Alexandoooor">View My GitHub Profile</a></li>
        </ul>

      </header>
      <section>

      <small>24 October 2025</small>
<h1>Implenting a Limit Order Book in golang</h1>

<p class="view">by Alexander</p>

<h2 id="what-is-a-limit-order-book">What is a Limit Order Book?</h2>

<p>From the Wikipedia article on <a href="https://en.wikipedia.org/wiki/Order_book">Order Books</a>.</p>
<blockquote>
  <p>An order book is the list of orders (manual or electronic) that a trading venue (in particular stock exchanges) uses to record the interest of buyers and sellers in a particular financial instrument. A matching engine uses the book to determine which orders can be fully or partially executed.</p>
</blockquote>

<p>A <em>Limit</em> Order Book is an order book that is comprised of <a href="https://en.wikipedia.org/wiki/Order_(exchange)#Limit_order">Limit orders</a>.</p>
<blockquote>
  <p>A limit order is an order to buy a security at no more than a specific price, or to sell a security at no less than a specific price (called “or better” for either direction). This gives the trader (customer) control over the price at which the trade is executed; however, the order may never be executed (“filled”). Limit orders are used when the trader wishes to control price rather than certainty of execution.</p>
</blockquote>

<p>Another important concept is <a href="https://en.wikipedia.org/wiki/Order_book">Price Levels</a></p>
<blockquote>
  <p>When several orders contain the same price, they are referred to as being on a price level. Practically, this means that if a bid comes at that price level, all the sell orders on that price level could potentially fulfill that.</p>
</blockquote>

<p><img src="/assets/img/ExampleRealBook.png" alt="Example of a real Order Book" />
<em>Example of a real order book</em></p>

<hr />
<h3 id="how-can-we-model-a-limit-order-book-in-go">How can we model a Limit Order Book in Go?</h3>
<h4 id="order-book">Order Book</h4>
<p>My implementation models the order book as the type <code class="language-plaintext highlighter-rouge">OrderBook</code> which stores maps of the price levels for each
side (bid/ask) and a map with all of the current orders. It was also helpful to keep references to the lowest ask and the highest bid.</p>

<p>In addition I also stored a slice of all executed trades. This is technically a separate component and not a part of an order book, but it is convenient to validate that the order matching works as expected.</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">OrderBook</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">levels</span>     <span class="k">map</span><span class="p">[</span><span class="n">Side</span><span class="p">]</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="n">Level</span>
	<span class="n">orders</span>     <span class="k">map</span><span class="p">[</span><span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span><span class="p">]</span><span class="o">*</span><span class="n">Order</span>
	<span class="n">lowestAsk</span>  <span class="o">*</span><span class="n">Level</span>
	<span class="n">highestBid</span> <span class="o">*</span><span class="n">Level</span>
	<span class="n">trades</span>     <span class="p">[]</span><span class="n">Trade</span>
	<span class="n">storage</span>    <span class="n">Storage</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The levels are split up into the respective sides.</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Side</span> <span class="kt">int</span>

<span class="k">const</span> <span class="p">(</span>
	<span class="n">Buy</span> <span class="n">Side</span> <span class="o">=</span> <span class="no">iota</span>
	<span class="n">Sell</span>
<span class="p">)</span>
</code></pre></div></div>
<hr />
<h4 id="price-levels">Price Levels</h4>
<p>Price levels are modeled as a linked list. Where each Level keeps a reference <code class="language-plaintext highlighter-rouge">nextLevel</code>.
<code class="language-plaintext highlighter-rouge">nextLevel</code> is needed because sometimes you need to traverse multiple levels in order to fully execute an order.
<code class="language-plaintext highlighter-rouge">nextLevel</code> is also used when adding a new level or removing a level when it becomes empty.</p>

<p>A level also contains <code class="language-plaintext highlighter-rouge">Volume</code> and <code class="language-plaintext highlighter-rouge">Count</code>. The volume is the total amount of shares contained in each order and the count is the number of orders in the level.</p>

<p>Furthermore, the orders in modeled as a doubly-linked list, <code class="language-plaintext highlighter-rouge">headOrder</code> and <code class="language-plaintext highlighter-rouge">tailOrder</code> are references to the first and last orders in the list, ordered by when the orders were placed.
This is to determine which order is to be matched against if there are multiple candiates that satisfy the conditions for execution of an incoming order.</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Level</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Price</span>     <span class="kt">int</span>
	<span class="n">Volume</span>    <span class="kt">int</span>
	<span class="n">Count</span>     <span class="kt">int</span>
	<span class="n">nextLevel</span> <span class="o">*</span><span class="n">Level</span>
	<span class="n">headOrder</span> <span class="o">*</span><span class="n">Order</span>
	<span class="n">tailOrder</span> <span class="o">*</span><span class="n">Order</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="example-traversing-multiple-levels">Example: Traversing multiple levels</h4>
<p>Imagine that this is the ask side of an order book.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">amount</th>
      <th style="text-align: left">price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">10</td>
      <td style="text-align: left">5</td>
    </tr>
    <tr>
      <td style="text-align: left">12</td>
      <td style="text-align: left">6</td>
    </tr>
    <tr>
      <td style="text-align: left">15</td>
      <td style="text-align: left">7</td>
    </tr>
  </tbody>
</table>

<p>You place a buy order for 30 units at price 7.
The matching engine will check and see that the <code class="language-plaintext highlighter-rouge">lowestAsk</code> points to the level with <code class="language-plaintext highlighter-rouge">Level.Price == 5</code>.
But the <code class="language-plaintext highlighter-rouge">Level.Volume == 10</code>, this means that the matching engine can only execute 10 units at price 5.</p>

<p>The matching engine will then need to traverse the list to the next level, the level with <code class="language-plaintext highlighter-rouge">Level.Price == 6</code>, where it can match another
12 shares at price 6. The engine will continue to traverse the levels, until either the order is completely filled, or when there are no more asks within the price limit.</p>

<hr />
<h4 id="orders">Orders</h4>
<p>Orders are modeled by the <code class="language-plaintext highlighter-rouge">Order</code> type.</p>
<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Order</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">ID</span>          <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span>
	<span class="n">Side</span>        <span class="n">Side</span>
	<span class="n">Size</span>        <span class="kt">int</span>
	<span class="n">Remaining</span>   <span class="kt">int</span>
	<span class="n">Price</span>       <span class="kt">int</span>
	<span class="n">Time</span>        <span class="n">time</span><span class="o">.</span><span class="n">Time</span>
	<span class="n">nextOrder</span>   <span class="o">*</span><span class="n">Order</span>
	<span class="n">prevOrder</span>   <span class="o">*</span><span class="n">Order</span>
	<span class="n">parentLevel</span> <span class="o">*</span><span class="n">Level</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The members are quite straight forward. As previously mentioned orders are structured as a doubly-linked list.</p>
<ul>
  <li>The reference to the <code class="language-plaintext highlighter-rouge">parentLevel</code> is needed to update the level <code class="language-plaintext highlighter-rouge">Count</code> and <code class="language-plaintext highlighter-rouge">Volume</code> when an order is added or removed.</li>
  <li>The member <code class="language-plaintext highlighter-rouge">Remaining</code> is needed since orders can be partially filled.</li>
</ul>

<hr />
<h4 id="trades">Trades</h4>

<p>The <code class="language-plaintext highlighter-rouge">Trade</code> type is self explanatory.</p>
<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Trade</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">ID</span>       <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span>
	<span class="n">Price</span>    <span class="kt">int</span>
	<span class="n">Size</span>     <span class="kt">int</span>
	<span class="n">Time</span>     <span class="n">time</span><span class="o">.</span><span class="n">Time</span>
	<span class="n">BuyOrderID</span>  <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span>
	<span class="n">SellOrderID</span> <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />
<h3 id="summary">Summary</h3>
<p>This was an interesting project and a fun way to practice writing Go.
A limit order book as a concept is quite simple. Implenting it was a bit more complicated though.
There are a lot of edge cases like partially filled orders, traversing multiple levels that needs to be handled.
Furthermore, many of the components are highly interconnected and it is important that updates to one component is correctly propagated to the others, in the right order.</p>

<p>The source of my Limit Order Book implementation is available in this <a href="https://github.com/Alexandoooor/limit-order-book">github repo</a>.</p>

<hr />
<h3 id="bonus-content">Bonus content</h3>
<h4 id="web-ui">Web-UI</h4>
<p>I added a simple Web-UI to interact with the Order Book.</p>

<p>It allows a user to add buy or sell orders with a given price and size. It shows a visual representation of the order book, as well as a list of executed trades.</p>

<p><em><strong>full disclosure:</strong> it is mostly vibe-coded using LLMs</em></p>

<p><img src="/assets/img/LimitOrderBook.png" alt="Limit Order Book" />
<em>Limit Order Book Web-UI</em></p>

<h4 id="persitency">Persitency</h4>
<p>I have also dabbled with persiting the state of the order book.
I have tried both dumping it to JSON and also writing and reading the state to a PostgreSQL database.</p>

<p>But I have not figured out completely when to read/write the state of the order book to the DB in order to keep the state correct.
In the JSON-case I could just keep one JSON-file with the whole state(<code class="language-plaintext highlighter-rouge">OrderBook</code>, <code class="language-plaintext highlighter-rouge">Level</code>, <code class="language-plaintext highlighter-rouge">Order</code> and <code class="language-plaintext highlighter-rouge">Trade</code> objects serialized).
At each change, adding a new order for example, I would just dump the state of all objects to the file, ensuring that the JSON-file always reflected the in-memory state.</p>

<p>This is not a pretty solution, and it did obviously not work for the database, as it would be insane to overwrite the whole database at each update.
One of the challenges of using the database is to correctly save and restore the objects that are structured as linked lists, ensuring correct ordering.</p>



  <small>tags: <em>golang</em></small>



      </section>
      <footer>
        
        <p><small>This project is maintained by <a href="https://github.com/Alexandoooor">Alexandoooor</a></small></p>
        
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>
